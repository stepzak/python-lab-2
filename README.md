# Лабораторная работа 2
## Вариант: E+M(с некоторым дополнениями :D)

* **Цель:** Написать мини-оболочку на Python с файловыми командами
* **Библиотеки:** *dataclass*, *importlib*, *inspect*, *sys*, *logging*, *readline*, *pytest*, *pathlib*
* **Допущения:**
  - Разрабатывалась под unix-системы. Поведение на Windows не определено. Удалите Windows

* **Чему я научился:**
    - Работа с pathlib, shutil, shlex
    - Работа с importlib, inspect
    - Исследование модулй и их динамическая загрузка/перезагрузка без необходимости перезапуска приложения

### Архитектура решения
  * cmd_types - здесь определяются кастомные типы для работы оболочки
  * decorators - здесь определяются декораторы(например: маркеры команд, обработчики)
  * extra - дополнительные утилиты
  * plugins - здесь находятся все плагины с определением логики работы команд(при загрузке плагины с полем *\_\_author\_\_ = 'default'* имеют наивысший приоритет
  * command_line_session - здесь находится класс сессии командной оболочки, обрабатывающий IO
  * constants - константы
  * main - точка входа в приложение
### Цикл работы приложения

  1. Создается объект сессии командной оболочки(далее - *СКО*). Запускается метод start() *СКО*, который автоматически подгружает все команды(должны быть помечены декоратором и наследовать класс **cmd_types.commands.ExecutableCommand**) плагинов(```plugin_*.py``` по умолчанию) в директории ```src/plugins```(умолч.), записывает их в словарь **cmd_map**({"имя_команды": <класс команды>}) и запускает вечный цикл. Если была указана строгая загрузка(**constants.STRICT_PLUGIN_LOADING**) и во время импорта команд произошла ошибка(н., несколько реализаций команд с одним и тем же именем), *СКО* не запустится, а выдаст ошибку
  2. Пользователь в интерактивном режиме вводит команду
  3. ```shlex``` разбивает строку с командой на имя команды и ее аргументы
  4. Если комана не была найдена в **cmd_map**, *СКО* напишет в логи и stdout ошибку и продолжит принимать команды
  5. Если команда была найдена, создается объект ее класса(далее - *ОбК*) с передачей массива аргументов.
  6. Вызывается метод *ОбК* **execute**
  7. Дальнейшие действия зависят от конкретной реализации метода класса команды. Чаще всего внутри вызывается метод **parse_args** для парсинга(иногда валидации) аргументов
  8. *ОбК* возвращает ответ **cmd_types.output.CommandOutput** с полями **stdout**, **stderr**, **errcode**(1 и 2 потоки команд в bash, код ошибки соответственно)
  9. *СКО* сначала выводит поле **stderr**, затем поле **stdout**. **stderr** дополнительно записывается в логи
  10. Цикл продолжается с шага 2 до тех пор, пока пользователь не вводит команду ```exit {code}```, где {code} - код ошибки выхода из *СКО*(ум. 0)
      
Более подробно с приложением можно ознакомиться в документации.
    

## Интересные тест-кейсы
 - Удаление, перемещение, копирование родительского каталога
 - cat с передачей бинарного файла в качестве аргумента

## Инструкция к использованию

### ПРОЧИТАТЬ ДОКУМЕНТАЦИЮ(желательно)
**Документация**: https://stepzak.github.io/python-lab-2/src.html

### Установить репозиторий
```pip install -e git+https://github.com/stepzak/python-lab-2#egg=python-lab-2``` \
```cd src/python-lab-2```

### Запустить
```python -m src.main```

```>>> help```

### Написание собственного плагина

Поддерживается написание собственных плагинов, без необходимости редактировать исходный код(необходимо только положить его в папку src/plugins, название должное начинаться с 'plugin_', ум.).
Документация для использования API расположена выше
